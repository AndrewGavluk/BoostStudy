# h1 Часть I - RAII and Memory Management
=====================================================================
	Первая часть посвящена управлению памяти. 
Для этого используются умные указатели(Smart Pointers, далее SP),
разделённые хранилища(segregated storage) и других 
полезных вещей.
	RAII - Resource Acquisition Is Initialization, 
инициализация рессурса при его получении. Идиома ООП
которая рекомендует что бы получение рессурса было 
непосредственно связанна с его инициализацией, 
а освобождение — с уничтожением объекта.

## h2 Ch. 1 Умные указатели:
---------------------------------------------------------------------
### h3 **Еденое владение:**
#### h4 * boost::scoped_ptr
Динамически выделяемого объекта, который автоматически
удаляется при выходе из области видимости. Это способствует
избежанию утечек памяти, копирование и перемещение (move) 
запрещенно. 
(определён в #include <boost/scoped_ptr.hpp>)
 
#### h4 * boost::scoped_array
Вариант scoped_ptr для массива
отличие заключается в том в конструкторе и деструкторе 
scoped_ptr используются new и delete,
scoped_array используются new[] и delete[]
(определён в #include <boost/scoped_array.hpp>)

### h3 **Множественное владение:**
#### h4 * ul boost::shared_ptr
Поведение данного указателя похоже на scoped_ptr, 
за исключением возможности передачи владения.
Данный объект имет два поля:
1 - содержит информацию
2 - счётчик указатей, указывает сколько объектов
ссылаются на данный SP, в текущий момент времени.
Когда счётчик указатей становится равным нулю,
объект удаляется.
(определён в #include <boost/shared_ptr.hpp>)

#### h4 * ul boost::shared_array
Аналог scoped_array, для boost::shared_ptr

Директива #define BOOST_SP_USE_QUICK_ALLOCATOR
позволяет быстрее освобождать память

#### h4 * ul boost::make_shared
Функция возвращающая boost::shared_ptr, 
как временный объект.
Так же различие заключается в том, 
что для shared_ptr память выделяется 2 раза - 
1-ый раз для рессурса
2-ой раз для счётчика указатей
для boost::make_shared выделяется 1 раз.
(определён в #include <boost/make_shared.hpp>)

#### h4 * ul std::shared_ptr 
Умный указатель, с разделяемым владением объектом 
через его указатель. Несколько указателей 
shared_ptr могут владеть одним и тем же объектом; 
объект будет уничтожен, когда последний shared_ptr, 
указывающий на него, будет уничтожен или сброшен.

#### h4 * ul boost::weak_ptr
Используется только вместе с shared_ptr, 
используется как "слабая" ссылка на обьект, 
т. е. счётчик ссылок не увеличивает, но 
"самоуничтожается".
boost::weak_ptr моделирует временное владение: 
когда объект должен быть доступен только если он 
существует и может быть удален в любой момент кем-то другим,
boost::weak_ptr используется для отслеживания объекта, 
и преобразуется в boost::shared_ptr для 
принятия временного владения. Если исходный 
boost::shared_ptr будет уничтожен в процессе работы, 
время жизни объекта продлевается до того момента, 
пока не будет разрушен временный boost::shared_ptr.
(определён в #include <boost/weak_ptr.hpp>)

#### h4 * ul boost::intrusive_ptr 
Аналог shared_ptr.
1. Не подерживает weak_ptr.
2. Более быстродейственен. 
(определён в #include <boost/intrusive_ptr.hpp>)

## h2 Ch. 2 Умные указатели (продолжение)
---------------------------------------------------------------------
Имеется целый ряд специальных классов, 
контейнеров для умных указателей:

* ul boost::ptr_vector<> - аналог std::vector<std::unique_ptr<>> 
* ul boost::ptr_set
* ul boost::ptr_deque 
* ul boost::ptr_list 
* ul boost::ptr_map 
* ul boost::ptr_unordered_set
* ul boost::ptr_unordered_map 

## h2 Ch. 3 BOOST_SCOPE_EXIT
Директива произваодящая действия с определёнными 
переменными (переданны в скобках), после выхода из 
скоупа

BOOST_SCOPE_EXIT (&a, &b, c)
{
	...
}
BOOST_SCOPE_EXIT_END
(определён в #include <boost/scope_exit.hpp>)

## h2 Ch. 4 Boost.Pool
---------------------------------------------------------------------






