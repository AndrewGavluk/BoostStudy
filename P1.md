	Часть I - RAII and Memory Management
	
	Первая часть посвящена управлению памяти. 
Для этого используются умные указатели(Smart Pointers, далее SP),
разделённые хранилища(segregated storage) и других 
полезных вещей.
 
	RAII - Resource Acquisition Is Initialization, 
инициализация рессурса при его получении. Идиома ООП
которая рекомендует что бы получение рессурса было 
непосредственно связанна с его инициализацией, 
а освобождение — с уничтожением объекта.

Ch. 1
Умные указатели:

Еденое владение:
boost::scoped_ptr
Динамически выделяемого объекта, который автоматически
удаляется при выходе из области видимости. Это способствует
избежанию утечек памяти, копирование и перемещение (move) 
запрещенно. 
(определён в #include <boost/scoped_ptr.hpp>)
 
boost::scoped_array
Вариант scoped_ptr для массива
отличие заключается в том в конструкторе и деструкторе 
scoped_ptr используются new и delete,
scoped_array используются new[] и delete[]
(определён в #include <boost/scoped_array.hpp>)

Множественное владение:
boost::shared_ptr
Поведение данного указателя похоже на scoped_ptr, 
за исключением возможности передачи владения.
Данный объект имет два поля:
1 - содержит информацию
2 - счётчик указатей, указывает сколько объектов
ссылаются на данный SP, в текущий момент времени.
Когда счётчик указатей становится равным нулю,
объект удаляется.
(определён в #include <boost/shared_ptr.hpp>)

boost::make_shared
Функция возвращающая boost::shared_ptr, 
как временный объект.
Так же различие заключается в том, 
что для shared_ptr память выделяется 2 раза - 
1-ый раз для рессурса
2-ой раз для счётчика указатей
для boost::make_shared выделяется 1 раз.
(определён в #include <boost/make_shared.hpp>)

Ch. 2
Умные указатели (продолжение):
boost::ptr_vector - 









